// Generated by CoffeeScript 1.7.1
(function() {
  var jqMaps, mapsUtils;

  mapsUtils = {
    extend: function() {
      var argL, i, key, out;
      out = {};
      argL = arguments.length;
      if (!argL) {
        return out;
      }
      i = 0;
      while (i < argL) {
        for (key in arguments[i]) {
          out[key] = arguments[i][key];
        }
        i++;
      }
      return out;
    },
    chargueJs: function(src) {
      var script;
      script = document.createElement('script');
      script.type = 'text/javascript';
      script.src = src;
      return document.body.appendChild(script);
    },
    unique: function() {
      return Math.random().toString(36).substr(2);
    },
    maps: {
      arrayCords: function(gmaps, coords) {
        var arrCords, coord, _i, _len;
        arrCords = [];
        for (_i = 0, _len = coords.length; _i < _len; _i += 1) {
          coord = coords[_i];
          if (coord.constructor !== Array) {
            arrCords = coords;
            break;
          }
          arrCords.push(new gmaps.LatLng(coord[0], coord[1]));
        }
        return arrCords;
      }
    },
    messages: {
      geolocation: {
        1: "Permiso denegado",
        2: "Posición no disponible",
        3: "Tiempo de espera agotado",
        4: "El navegador no soporta geolocation"
      }
    }
  };


  /*class customOverlay
  	constructor: (options,map)->
  		@map_= map
  
  		@bounds_= options.coords || []
  		@div_= options.content
  		@pane_= options.pane || "floatPane"
  		@position= options.position || null
  
  		@setMap map
  	 *Método estático
  	@autoload= (nspace)->
  		customOverlay.prototype= new nspace.OverlayView()
  		customOverlay::onAdd= -> 
  			panes= this.getPanes()
  			panes[@pane_].appendChild(@div_)
  		customOverlay::draw= ->
  			overlayProjection = this.getProjection()
  			if @bounds_.constructor is Array
  				@bounds_= mapsUtils.maps.arrayCords nspace, @bounds_
  			@calcPosition(overlayProjection)
  		customOverlay::calcPosition= (objOverlay)->
  			if @position isnt null
  				@position&&@position(objOverlay,@div_,@bounds_)
  			else
  				div= @div_
  				overlayP= {} 
  				console.log @bounds_
  				if @bounds_.constructor is Array
  					sw= objOverlay.fromLatLngToDivPixel(@bounds_[0])
  					ne= objOverlay.fromLatLngToDivPixel(@bounds_[1])
  					overlayP.left= sw.x + 'px'
  					overlayP.top= ne.y + 'px'
  				else
  					cord= objOverlay.fromLatLngToDivPixel(@bounds_)
  					overlayP.left= cord.x + 'px'
  					overlayP.top= cord.y + 'px'				
  				div.style.left= overlayP.left
  				div.style.top= overlayP.top
  		customOverlay::onRemove= ->
  			@div_.parentNode.removeChild(@div_)
  			@div_= null
   */

  window.jqMaps = jqMaps = (function() {
    function jqMaps(options) {
      var opt;
      opt = {
        id: "jqMaps",
        protocol: "http",
        sensor: "true",
        geolocation: {
          state: false,
          success: null,
          error: null
        },
        success: null
      };
      this.settings = mapsUtils.extend(opt, options);
      this.el = null;
      this.opts = {
        zoom: 8,
        lt: -8.59087,
        lg: -77.1025,
        mapTypeId: "ROADMAP",
        streetViewControl: true,
        panControl: true,
        zoomControl: true,
        mapTypeControl: false,
        scaleControl: false,
        streetViewControl: true,
        overviewMapControl: false
      };
      this.dispatchState = false;
      this.registerMethods = [];
      this.markers = {};
      this.polilynes = {};
      this.map = null;
      this._init();
    }

    jqMaps.prototype._init = function() {
      return this._chargeLib();
    };

    jqMaps.prototype._dispatch = function() {
      var opts, settings, target;
      this.nspace = google.maps;
      settings = this.settings;
      this.el = document.getElementById(settings.id) || false;
      if (this.nspace === void 0) {
        throw "la carga de google maps a fallado o es una version no soportada";
      }
      if (this.el) {
        target = this.el;
        opts = this._getOpts();

        /*customOverlay.autoload(@nspace)												#Extendiendo la clase OverlayView */
        if (settings.geolocation.state) {
          return this._geolocation(target);
        } else {
          this.map = this.map === null ? new this.nspace.Map(target, opts) : void 0;
          this.dispatchState = true;
          this._dispatchMethods();
          return settings.success && settings.success(this.map, this.nspace);
        }
      } else {
        throw "el objeto map no existe en el documento";
      }
    };

    jqMaps.prototype._dispatchMethods = function() {
      var collectionMethod, method, params, status, _i, _len, _ref, _results, _this;
      _this = this;
      if (this.dispatchState) {
        _ref = this.registerMethods;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i += 1) {
          collectionMethod = _ref[_i];
          method = collectionMethod.method;
          params = collectionMethod.params;
          status = collectionMethod.status;
          if (status) {
            collectionMethod.func();
            _results.push(collectionMethod.status = 0);
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };

    jqMaps.prototype._getOpts = function(opts) {
      var _this;
      _this = this;
      opts = this.opts;
      return {
        center: new _this.nspace.LatLng(opts.lt, opts.lg),
        zoom: opts.zoom,
        mapTypeId: _this.nspace.MapTypeId[opts.mapTypeId],
        streetViewControl: opts.streetViewControl,
        panControl: opts.panControl,
        zoomControl: opts.zoomControl,
        mapTypeControl: opts.mapTypeControl,
        scaleControl: opts.scaleControl,
        streetViewControl: opts.streetViewControl,
        overviewMapControl: opts.overviewMapControl
      };
    };

    jqMaps.prototype._chargeLib = function() {
      var url, _this;
      _this = this;
      window.jqMapsDispatch = function() {
        return _this._dispatch();
      };
      url = this.settings.protocol + "://maps.googleapis.com/maps/api/js?sensor=" + this.settings.sensor + "&callback=jqMapsDispatch";
      return mapsUtils.chargueJs(url);
    };

    jqMaps.prototype._geolocation = function(target) {
      var geolocation, settings, _this;
      _this = this;
      settings = this.settings;
      geolocation = settings.geolocation;
      if (navigator.geolocation) {
        return navigator.geolocation.getCurrentPosition((function(position) {
          var opts;
          geolocation.success && geolocation.success(position);
          _this.opts.zoom = 18;
          _this.opts.lt = position.coords.latitude;
          _this.opts.lg = position.coords.longitude;
          opts = _this._getOpts();
          _this.map = _this.map === null ? new _this.nspace.Map(target, opts) : void 0;
          _this.dispatchState = true;
          _this._dispatchMethods();
          return settings.success && settings.success(_this.map, _this.nspace);
        }), (function(error) {
          return geolocation.error && geolocation.error(error);
        }), {
          enableHighAccuracy: true,
          timeout: 30000,
          maximumAge: 0
        });
      } else {
        return geolocation.error && geolocation.error(4, mapsUtils.messages.geolocation["4"]);
      }
    };

    jqMaps.prototype._addMethods = function(method) {
      method.status = 1;
      this.registerMethods.push(method);
      return this._dispatchMethods();
    };

    jqMaps.prototype.setOpts = function(opts) {
      var _this;
      _this = this;
      return this.opts = mapsUtils.extend(_this.opts, opts);
    };

    jqMaps.prototype.mapEvents = function(mapOpts) {
      var _this;
      _this = this;
      return this._addMethods({
        method: 'evt',
        params: mapOpts,
        func: function() {
          var nameEvt, _results;
          _results = [];
          for (nameEvt in mapOpts) {
            _results.push(_this.nspace.event.addListener(_this.map, nameEvt, mapOpts[nameEvt]));
          }
          return _results;
        }
      });
    };

    jqMaps.prototype.addMarker = function(markerOpts) {
      var idMarker, _this;
      _this = this;
      idMarker = markerOpts.id || mapsUtils.unique();
      return this._addMethods({
        method: "marker",
        params: markerOpts,
        func: function() {
          var markerObj, nameEvt, settings, _results;
          settings = {};
          if (!markerOpts.hasOwnProperty("position")) {
            settings.position = new _this.nspace.LatLng(markerOpts.lt || -8.59087, markerOpts.lg || -77.1025);
          } else {
            settings.position = markerOpts.position;
          }
          settings.title = markerOpts.title || "";
          settings.map = _this.map;
          settings.draggable = markerOpts.draggable || false;
          settings.icon = markerOpts.icon;
          if (markerOpts.icon.constructor === Object && markerOpts.icon.path !== "") {
            settings.icon.path = _this.nspace.SymbolPath[markerOpts.icon.path];
          }
          settings.id = idMarker;
          settings.fixed = markerOpts.fixed || false;
          markerObj = new _this.nspace.Marker(settings);
          _this.markers[idMarker] = markerObj;
          markerObj.gmap = _this;
          markerObj.data = markerOpts.data || "";
          _results = [];
          for (nameEvt in markerOpts.evts) {
            _results.push(_this.nspace.event.addListener(markerObj, nameEvt, markerOpts.evts[nameEvt]));
          }
          return _results;
        }
      });
    };

    jqMaps.prototype.addPolyline = function(polilyneOpts) {
      var idPolilyne, _this;
      _this = this;
      idPolilyne = polilyneOpts.id || mapsUtils.unique();
      return this._addMethods({
        method: "polilyne",
        params: polilyneOpts,
        func: function() {
          var nameEvt, polilyneObj, settings;
          settings = {};
          if (polilyneOpts.hasOwnProperty("path")) {
            settings.path = mapsUtils.maps.arrayCords(_this.nspace, polilyneOpts.path);
          }
          settings.id = idPolilyne;
          settings.strokeColor = polilyneOpts.strokeColor || "#FF0000";
          settings.strokeOpacity = polilyneOpts.strokeOpacity || 1.0;
          settings.strokeWeight = polilyneOpts.strokeWeight || 2;
          polilyneObj = new _this.nspace.Polyline(settings);
          _this.polilynes[idPolilyne] = polilyneObj;
          polilyneObj.gmap = _this;
          polilyneObj.data = polilyneObj.data || "";
          for (nameEvt in polilyneOpts.evts) {
            _this.nspace.event.addListener(polilyneObj, nameEvt, polilyneOpts.evts[nameEvt]);
          }
          return polilyneObj.setMap(_this.map);
        }
      });
    };


    /*addCustomOverlay: (customOverlayOpts)->
    		new customOverlay customOverlayOpts, @map
     */

    jqMaps.prototype.getMap = function() {
      return this.map;
    };

    jqMaps.prototype.getMarker = function(idMarker) {
      return this.markers[idMarker];
    };

    jqMaps.prototype.getPolyline = function(idPolilyne) {
      return this.polilynes[idPolilyne];
    };

    return jqMaps;

  })();

}).call(this);
